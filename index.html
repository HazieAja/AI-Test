<!DOCTYPE html><html lang="en">
<head>
<meta charset="UTF-8">
<title>Maze AI Simulator (Procedural Maze)</title>
<style>
body{
  margin:0;
  font-family:system-ui, monospace;
  background:radial-gradient(circle at top,#2b2d42,#0f1020);
  display:flex;
  align-items:center;
  justify-content:center;
  height:100vh;
}
#panel{
  width:720px;
  background:rgba(255,255,255,0.95);
  padding:18px;
  border-radius:18px;
  box-shadow:0 25px 60px rgba(0,0,0,.45);
}
#controls{
  display:flex;
  gap:10px;
  justify-content:center;
  margin-bottom:10px;
}
canvas{
  display:block;
  margin:auto;
  background:linear-gradient(#fafafa,#f0f0f0);
  border-radius:14px;
}
select,input,button{
  padding:8px 12px;
  border-radius:10px;
  border:none;
  background:#edf2ff;
  box-shadow:inset 0 0 0 1px #c7d2fe;
}
button{
  background:#6366f1;
  color:white;
  cursor:pointer;
}
button:hover{background:#4f46e5;}
</style>
</head>
<body>
<div id="panel">
  <div id="controls">
    <select id="mode">
      <option value="single">Single AI</option>
      <option value="multi">Multi AI</option>
    </select>
    <input id="count" type="number" min="1" max="6" value="2">
    <select id="speed">
      <option value="300">Slow</option>
      <option value="150" selected>Normal</option>
      <option value="60">Fast</option>
    </select>  </div>
  <canvas id="cv"></canvas>
</div><script>
// ===== CONFIG =====
const CELL = 28;
const MAZE_W = 17; // odd number
const MAZE_H = 17;

// ===== STATE =====
let grid, ROWS, COLS;
let agents=[];
let spawnPoints={};
let scores={};
let timer=null;
let goalLock=false;

// ===== CANVAS =====
const cv = document.getElementById('cv');
const ctx = cv.getContext('2d');

// ===== MAZE GENERATOR (DFS) =====
function generateMaze(){
  ROWS = MAZE_H;
  COLS = MAZE_W;

  grid = Array.from({length:ROWS},()=>Array(COLS).fill('#'));

  function carve(r,c){
    grid[r][c]='.';
    const dirs=[[2,0],[-2,0],[0,2],[0,-2]].sort(()=>Math.random()-0.5);
    for(const [dr,dc] of dirs){
      const nr=r+dr, nc=c+dc;
      if(nr>0 && nc>0 && nr<ROWS-1 && nc<COLS-1 && grid[nr][nc]==='#'){
        grid[r+dr/2][c+dc/2]='.';
        carve(nr,nc);
      }
    }
  }

  carve(1,1);

  // goal
  grid[ROWS-2][COLS-2]='G';

  // kill pads
  for(let i=0;i<5;i++){
    let r,c;
    do{
      r=1+Math.floor(Math.random()*(ROWS-2));
      c=1+Math.floor(Math.random()*(COLS-2));
    }while(grid[r][c]!=='.');
    grid[r][c]='X';
  }

  cv.width = COLS * CELL;
  cv.height = ROWS * CELL;
}
}

// ===== SIM START =====
function autoStart(){
  clearInterval(timer);
  agents=[];
  spawnPoints={};
  scores={};
  goalLock=false;

  generateMaze();
  draw(); // <-- PENTING: paksa render maze

  const n = mode.value === 'single' ? 1 : Number(count.value);
  for(let i=0;i<n;i++) agents.push(spawnAgent(i));

  timer=setInterval(stepAll,Number(speed.value));
}

// ===== SIM LOOP =====

timer=setInterval(stepAll,Number(speed.value));
}

// ===== AGENTS =====
function spawnAgent(id){
  let r,c;
  do{
    r=1+Math.floor(Math.random()*(ROWS-2));
    c=1+Math.floor(Math.random()*(COLS-2));
  }while(grid[r][c]!=='.');

  spawnPoints[id]={r,c};
  scores[id]=0;

  return {id,r,c,penaltyCD:0};
}
}

function occupied(r,c,self){
  return agents.some(a=>a!==self && a.r===r && a.c===c);
}

// ===== STEP =====
function stepAll(){
  if(goalLock) return;
  for(const a of agents){
    if(a.penaltyCD>0) a.penaltyCD--;
    step(a);
  }
  draw();
}

// ===== STEP =====(){
  if(goalLock) return;
  for(const a of agents) step(a);
  draw();
}

function step(a){
  const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
  const [dr,dc]=dirs[Math.floor(Math.random()*4)];
  const nr=a.r+dr, nc=a.c+dc;

  if(grid[nr][nc]==='#'){
    scores[a.id]-=20;
    return;
  }
  if(occupied(nr,nc,a)) return;

  a.r=nr; a.c=nc;

  if(grid[nr][nc]==='X' && a.penaltyCD<=0){
    scores[a.id]-=200;
    a.penaltyCD=5;
  }

  if(grid[nr][nc]==='G' && !goalLock){
    goalLock=true;
    scores[a.id]++;
    setTimeout(resetRound,700);
  }
}

function resetRound(){
  for(const a of agents){
    const s=spawnPoints[a.id];
    a.r=s.r;
    a.c=s.c;
  }
  goalLock=false;
}

// ===== DRAW =====
function draw(){
  ctx.clearRect(0,0,cv.width,cv.height);

  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const cell=grid[r][c];
      const x=c*CELL, y=r*CELL;

      if(cell==='#'){
        ctx.fillStyle='#2f2f2f';
        ctx.fillRect(x,y,CELL,CELL);
      }else{
        ctx.fillStyle='#fdfdfd';
        ctx.fillRect(x,y,CELL,CELL);
      }

      if(cell==='G'){
        ctx.fillStyle='#4ade80';
        ctx.fillRect(x+6,y+6,CELL-12,CELL-12);
      }
      if(cell==='X'){
        ctx.fillStyle='#ef4444';
        ctx.fillRect(x+8,y+8,CELL-16,CELL-16);
      }

      if(cell==='G'){
        ctx.fillStyle='#4ade80';
        ctx.fillRect(x+6,y+6,CELL-12,CELL-12);
      }
    }
  }

  for(const a of agents){
    const ax=a.c*CELL+CELL/2;
    const ay=a.r*CELL+CELL/2;

    ctx.fillStyle='#4dabf7';
    ctx.beginPath();
    ctx.arc(ax,ay,10,0,Math.PI*2);
    ctx.fill();

    ctx.fillStyle='#000';
    ctx.font='10px monospace';
    ctx.fillText(`P:${scores[a.id]}`,ax-10,ay+22);
  }
}

// ===== AUTO START =====
function autoStart(){
  clearInterval(timer);
  agents=[];
  spawnPoints={};
  scores={};
  goalLock=false;

  generateMaze();
  draw();

  const n = mode.value === 'single' ? 1 : Number(count.value);
  for(let i=0;i<n;i++) agents.push(spawnAgent(i));

  timer=setInterval(stepAll,Number(speed.value));
}

// langsung jalan
setTimeout(autoStart,100);

// restart otomatis kalau setting berubah
mode.onchange = count.onchange = speed.onchange = autoStart;
